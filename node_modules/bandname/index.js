var data = {
    n_abstract: require('./data/n_abstract.js').data,
    adj_personality: require('./data/adj_personality.js').data,
    name_first: require('./data/name_first.js').data
}

var patterns = [
    "The {{n_abstract}} of {{n_abstract}}",
    "{{n_abstract}}'s {{n_abstract}}",
    "{{adj_personality}} {{name_first}} and the {{n_abstract}}",
    "{{name_first}} and the {{n_abstract}}",
    // N on the N
    // The Adj (Pl)N
    // n_abstract+n_concrete (eg. doomtree)
    // Name and the Adj (or gerund) PlN
    // PlN of Place
    // Name the adj_personality N
    // adj_personality PlN V PlN (eg pretty girls make graves)
    // gerund name
    
]

function randElem(list) {
    return list[Math.floor(Math.random() * list.length)];
}

function capitalize(str) {
    var words = str.split(" ");
    for (var i = 0; i < words.length; i++) {
        var j = words[i].charAt(0).toUpperCase();
        words[i] = j + words[i].substr(1);
    }
    return words.join(" ");
}

function generatePhraseFromPattern(pattern) {
    var phrase = pattern;
    for(var token in data) { // for each type eg. abstract non
        var regex = new RegExp('{{' + token + '}}', 'g');
        if(pattern.match(regex)) {
            for(var i=0; i<pattern.match(regex).length; i++) { // for each occurrence of type
                phrase = phrase.replace('{{' + token + '}}', capitalize(randElem(data[token])))
            }
        }
    }
    return phrase;
}

exports.generate = function() {
    return generatePhraseFromPattern(randElem(patterns));
}